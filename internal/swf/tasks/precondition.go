package tasks

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/openshift-hyperfleet/hyperfleet-adapter/internal/criteria"
	"github.com/openshift-hyperfleet/hyperfleet-adapter/internal/hyperfleet_api"
	"github.com/openshift-hyperfleet/hyperfleet-adapter/pkg/logger"
)

// DEPRECATION NOTICE:
// The hf:precondition and hf:preconditions tasks are deprecated in favor of native
// Serverless Workflow constructs. The converter now generates:
//   - call:http tasks for API calls
//   - export expressions to capture fields and evaluate conditions
//   - if conditions for short-circuit behavior
//   - set tasks for final allMatched/notMetReason computation
//
// These custom tasks are kept for backward compatibility with existing workflows
// but should not be used for new implementations. Use the native SWF approach
// generated by convertPreconditionsPhase() in converter/adapter_to_swf.go instead.

// PreconditionTaskRunner implements the hf:precondition task.
// Deprecated: Use native SWF call:http with export instead.
// It evaluates a single precondition including API calls, field capture, and conditions.
type PreconditionTaskRunner struct {
	apiClient hyperfleet_api.Client
	log       logger.Logger
}

// NewPreconditionTaskRunner creates a new precondition task runner.
func NewPreconditionTaskRunner(deps *Dependencies) (TaskRunner, error) {
	var apiClient hyperfleet_api.Client
	var log logger.Logger

	if deps != nil {
		if deps.APIClient != nil {
			var ok bool
			apiClient, ok = deps.APIClient.(hyperfleet_api.Client)
			if !ok {
				return nil, fmt.Errorf("invalid APIClient type")
			}
		}
		if deps.Logger != nil {
			var ok bool
			log, ok = deps.Logger.(logger.Logger)
			if !ok {
				log = &noopLogger{}
			}
		} else {
			log = &noopLogger{}
		}
	} else {
		log = &noopLogger{}
	}

	return &PreconditionTaskRunner{
		apiClient: apiClient,
		log:       log,
	}, nil
}

func (r *PreconditionTaskRunner) Name() string {
	return TaskPrecondition
}

// Run evaluates a precondition.
// Args should contain:
//   - name: Precondition name
//   - apiCall: Optional API call config (method, url, headers, body, timeout, retryAttempts, retryBackoff)
//   - capture: Optional array of fields to capture from API response
//   - conditions: Optional array of structured conditions
//   - expression: Optional CEL expression
//
// Returns a map with:
//   - matched: Boolean indicating if the precondition matched
//   - capturedFields: Map of captured field values
//   - apiCallMade: Boolean indicating if an API call was made
//   - error: Error message if evaluation failed
func (r *PreconditionTaskRunner) Run(ctx context.Context, args map[string]any, input map[string]any) (map[string]any, error) {
	name, _ := args["name"].(string)
	if name == "" {
		name = "unnamed"
	}

	output := make(map[string]any)
	for k, v := range input {
		output[k] = v
	}

	capturedFields := make(map[string]any)
	var apiResponseData map[string]any

	// Step 1: Execute API call if configured
	if apiCallConfig, ok := args["apiCall"].(map[string]any); ok {
		if r.apiClient == nil {
			return nil, fmt.Errorf("API client not configured for precondition %s", name)
		}

		method, _ := apiCallConfig["method"].(string)
		url, _ := apiCallConfig["url"].(string)

		// Render URL template if needed
		if params, ok := input["params"].(map[string]any); ok {
			renderedURL, err := RenderTemplate(url, params)
			if err == nil {
				url = renderedURL
			}
		}

		r.log.Infof(ctx, "Precondition[%s] making API call: %s %s", name, method, url)

		// Build request options
		var opts []hyperfleet_api.RequestOption

		if headers, ok := apiCallConfig["headers"].(map[string]any); ok {
			headerMap := make(map[string]string)
			for k, v := range headers {
				if s, ok := v.(string); ok {
					headerMap[k] = s
				}
			}
			opts = append(opts, hyperfleet_api.WithHeaders(headerMap))
		}

		// Execute the API call
		var resp *hyperfleet_api.Response
		var err error

		switch strings.ToUpper(method) {
		case "GET":
			resp, err = r.apiClient.Get(ctx, url, opts...)
		case "POST":
			var body []byte
			if bodyStr, ok := apiCallConfig["body"].(string); ok {
				body = []byte(bodyStr)
			}
			resp, err = r.apiClient.Post(ctx, url, body, opts...)
		default:
			resp, err = r.apiClient.Get(ctx, url, opts...)
		}

		output["apiCallMade"] = true

		if err != nil || resp == nil || !resp.IsSuccess() {
			errMsg := "API call failed"
			if err != nil {
				errMsg = err.Error()
			} else if resp != nil {
				errMsg = fmt.Sprintf("HTTP %d: %s", resp.StatusCode, resp.Status)
			}
			output["matched"] = false
			output["error"] = errMsg
			return output, nil
		}

		// Parse response
		if err := json.Unmarshal(resp.Body, &apiResponseData); err != nil {
			output["matched"] = false
			output["error"] = fmt.Sprintf("failed to parse API response: %v", err)
			return output, nil
		}

		// Store response under precondition name
		output[name] = apiResponseData

		// Capture fields
		if captures, ok := args["capture"].([]any); ok && len(captures) > 0 {
			captureCtx := criteria.NewEvaluationContext()
			captureCtx.SetVariablesFromMap(apiResponseData)

			captureEvaluator, evalErr := criteria.NewEvaluator(ctx, captureCtx, r.log)
			if evalErr == nil {
				for _, c := range captures {
					captureDef, ok := c.(map[string]any)
					if !ok {
						continue
					}
					captureName, _ := captureDef["name"].(string)
					field, _ := captureDef["field"].(string)
					expression, _ := captureDef["expression"].(string)

					if captureName == "" {
						continue
					}

					extractResult, err := captureEvaluator.ExtractValue(field, expression)
					if err == nil && extractResult.Value != nil {
						capturedFields[captureName] = extractResult.Value
						r.log.Debugf(ctx, "Captured %s = %v", captureName, extractResult.Value)
					}
				}
			}
		}
	}

	output["capturedFields"] = capturedFields

	// Merge captured fields into params
	if params, ok := output["params"].(map[string]any); ok {
		for k, v := range capturedFields {
			params[k] = v
		}
	}

	// Step 2: Evaluate conditions
	evalCtx := criteria.NewEvaluationContext()
	for k, v := range input {
		evalCtx.Set(k, v)
	}
	if apiResponseData != nil {
		evalCtx.Set(name, apiResponseData)
	}
	for k, v := range capturedFields {
		evalCtx.Set(k, v)
	}

	evaluator, err := criteria.NewEvaluator(ctx, evalCtx, r.log)
	if err != nil {
		output["matched"] = false
		output["error"] = fmt.Sprintf("failed to create evaluator: %v", err)
		return output, nil
	}

	matched := true

	// Evaluate structured conditions
	if conditions, ok := args["conditions"].([]any); ok && len(conditions) > 0 {
		var condDefs []criteria.ConditionDef
		for _, c := range conditions {
			condMap, ok := c.(map[string]any)
			if !ok {
				continue
			}
			field, _ := condMap["field"].(string)
			operator, _ := condMap["operator"].(string)
			value := condMap["value"]

			condDefs = append(condDefs, criteria.ConditionDef{
				Field:    field,
				Operator: criteria.Operator(operator),
				Value:    value,
			})
		}

		condResult, err := evaluator.EvaluateConditions(condDefs)
		if err != nil {
			output["matched"] = false
			output["error"] = fmt.Sprintf("condition evaluation failed: %v", err)
			return output, nil
		}

		matched = condResult.Matched
	} else if expression, ok := args["expression"].(string); ok && expression != "" {
		// Evaluate CEL expression
		celResult, err := evaluator.EvaluateCEL(strings.TrimSpace(expression))
		if err != nil {
			output["matched"] = false
			output["error"] = fmt.Sprintf("CEL evaluation failed: %v", err)
			return output, nil
		}
		matched = celResult.Matched
	}

	output["matched"] = matched

	if matched {
		r.log.Infof(ctx, "Precondition[%s] evaluated: MET", name)
	} else {
		r.log.Infof(ctx, "Precondition[%s] evaluated: NOT_MET", name)
	}

	return output, nil
}

// PreconditionsTaskRunner implements the hf:preconditions task.
// Deprecated: Use native SWF constructs generated by convertPreconditionsPhase() instead.
// It evaluates multiple preconditions in sequence, stopping on first failure.
type PreconditionsTaskRunner struct {
	apiClient hyperfleet_api.Client
	log       logger.Logger
}

// NewPreconditionsTaskRunner creates a new preconditions task runner.
func NewPreconditionsTaskRunner(deps *Dependencies) (TaskRunner, error) {
	var apiClient hyperfleet_api.Client
	var log logger.Logger

	if deps != nil {
		if deps.APIClient != nil {
			var ok bool
			apiClient, ok = deps.APIClient.(hyperfleet_api.Client)
			if !ok {
				return nil, fmt.Errorf("invalid APIClient type")
			}
		}
		if deps.Logger != nil {
			var ok bool
			log, ok = deps.Logger.(logger.Logger)
			if !ok {
				log = &noopLogger{}
			}
		} else {
			log = &noopLogger{}
		}
	} else {
		log = &noopLogger{}
	}

	return &PreconditionsTaskRunner{
		apiClient: apiClient,
		log:       log,
	}, nil
}

func (r *PreconditionsTaskRunner) Name() string {
	return TaskPreconditions
}

// Run evaluates multiple preconditions in sequence.
// Args should contain:
//   - config: Array of precondition configurations
//   - context: Current workflow context
//
// Returns a map with:
//   - allMatched: Boolean indicating if all preconditions matched
//   - results: Array of individual precondition results
//   - notMetReason: String explaining why preconditions weren't met (if applicable)
func (r *PreconditionsTaskRunner) Run(ctx context.Context, args map[string]any, input map[string]any) (map[string]any, error) {
	output := make(map[string]any)
	for k, v := range input {
		output[k] = v
	}

	preconditions, ok := args["config"].([]any)
	if !ok || len(preconditions) == 0 {
		output["allMatched"] = true
		output["results"] = []any{}
		return output, nil
	}

	results := make([]any, 0, len(preconditions))
	allMatched := true
	var notMetReason string

	// Create single precondition runner
	singleRunner, err := NewPreconditionTaskRunner(&Dependencies{
		APIClient: r.apiClient,
		Logger:    r.log,
	})
	if err != nil {
		return nil, err
	}

	for _, precondConfig := range preconditions {
		precondArgs, ok := precondConfig.(map[string]any)
		if !ok {
			continue
		}

		result, err := singleRunner.Run(ctx, precondArgs, input)
		if err != nil {
			allMatched = false
			notMetReason = fmt.Sprintf("precondition evaluation error: %v", err)
			results = append(results, map[string]any{
				"name":    precondArgs["name"],
				"matched": false,
				"error":   err.Error(),
			})
			break
		}

		matched, _ := result["matched"].(bool)
		results = append(results, map[string]any{
			"name":           precondArgs["name"],
			"matched":        matched,
			"capturedFields": result["capturedFields"],
			"apiCallMade":    result["apiCallMade"],
		})

		// Merge captured fields into input for next precondition
		if capturedFields, ok := result["capturedFields"].(map[string]any); ok {
			if params, ok := input["params"].(map[string]any); ok {
				for k, v := range capturedFields {
					params[k] = v
				}
			}
		}

		if !matched {
			allMatched = false
			name, _ := precondArgs["name"].(string)
			notMetReason = fmt.Sprintf("precondition '%s' not met", name)
			break
		}
	}

	output["allMatched"] = allMatched
	output["results"] = results
	if notMetReason != "" {
		output["notMetReason"] = notMetReason
	}

	return output, nil
}

func init() {
	_ = RegisterDefault(TaskPrecondition, NewPreconditionTaskRunner)
	_ = RegisterDefault(TaskPreconditions, NewPreconditionsTaskRunner)
}
