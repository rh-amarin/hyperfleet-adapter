package tasks

import (
	"context"
	"encoding/json"
	"fmt"
	"strings"

	"github.com/openshift-hyperfleet/hyperfleet-adapter/internal/criteria"
	"github.com/openshift-hyperfleet/hyperfleet-adapter/internal/hyperfleet_api"
	"github.com/openshift-hyperfleet/hyperfleet-adapter/pkg/logger"
)

// DEPRECATION NOTICE:
// The hf:post task is deprecated in favor of native Serverless Workflow constructs.
// The converter now generates:
//   - set tasks with jq expressions for simple payload fields
//   - hf:cel tasks for complex CEL expressions in payload building
//   - call:http tasks for API calls with native try/catch for retry
//
// This custom task is kept for backward compatibility with existing workflows
// but should not be used for new implementations. Use the native SWF approach
// generated by convertPostPhase() in converter/adapter_to_swf.go instead.

// PostTaskRunner implements the hf:post task for post-processing actions.
// Deprecated: Use native SWF constructs (set, call:http, try/catch) instead.
// It handles payload building and API calls after resource creation.
type PostTaskRunner struct {
	apiClient hyperfleet_api.Client
	log       logger.Logger
}

// NewPostTaskRunner creates a new post task runner.
func NewPostTaskRunner(deps *Dependencies) (TaskRunner, error) {
	var apiClient hyperfleet_api.Client
	var log logger.Logger

	if deps != nil {
		if deps.APIClient != nil {
			var ok bool
			apiClient, ok = deps.APIClient.(hyperfleet_api.Client)
			if !ok {
				return nil, fmt.Errorf("invalid APIClient type")
			}
		}
		if deps.Logger != nil {
			var ok bool
			log, ok = deps.Logger.(logger.Logger)
			if !ok {
				log = &noopLogger{}
			}
		} else {
			log = &noopLogger{}
		}
	} else {
		log = &noopLogger{}
	}

	return &PostTaskRunner{
		apiClient: apiClient,
		log:       log,
	}, nil
}

func (r *PostTaskRunner) Name() string {
	return TaskPost
}

// Run executes post-processing actions.
// Args should contain:
//   - payloads: Array of payload configurations
//   - postActions: Array of post-action configurations
//
// Returns a map with:
//   - payloads: Map of built payloads
//   - results: Array of post-action results
//   - success: Boolean indicating if all actions succeeded
func (r *PostTaskRunner) Run(ctx context.Context, args map[string]any, input map[string]any) (map[string]any, error) {
	output := make(map[string]any)
	for k, v := range input {
		output[k] = v
	}

	params, _ := input["params"].(map[string]any)
	if params == nil {
		params = make(map[string]any)
	}

	builtPayloads := make(map[string]any)
	allSuccess := true

	// Step 1: Build payloads
	if payloadsRaw, ok := args["payloads"].([]any); ok && len(payloadsRaw) > 0 {
		r.log.Infof(ctx, "Post: building %d payloads", len(payloadsRaw))

		// Create evaluation context
		evalCtx := criteria.NewEvaluationContext()
		for k, v := range input {
			evalCtx.Set(k, v)
		}

		evaluator, err := criteria.NewEvaluator(ctx, evalCtx, r.log)
		if err != nil {
			output["error"] = fmt.Sprintf("failed to create evaluator: %v", err)
			output["success"] = false
			return output, nil
		}

		for _, payloadRaw := range payloadsRaw {
			payload, ok := payloadRaw.(map[string]any)
			if !ok {
				continue
			}

			name, _ := payload["name"].(string)
			if name == "" {
				continue
			}

			// Determine build source
			var buildDef any
			if build, ok := payload["build"]; ok && build != nil {
				buildDef = build
			} else if buildRefContent, ok := payload["buildRefContent"].(map[string]any); ok {
				buildDef = buildRefContent
			} else {
				output["error"] = fmt.Sprintf("payload '%s' has neither build nor buildRefContent", name)
				output["success"] = false
				return output, nil
			}

			// Build the payload
			builtPayload, err := r.buildPayload(ctx, buildDef, evaluator, params)
			if err != nil {
				output["error"] = fmt.Sprintf("failed to build payload '%s': %v", name, err)
				output["success"] = false
				return output, nil
			}

			// Convert to JSON string for template rendering
			jsonBytes, err := json.Marshal(builtPayload)
			if err != nil {
				output["error"] = fmt.Sprintf("failed to marshal payload '%s': %v", name, err)
				output["success"] = false
				return output, nil
			}

			builtPayloads[name] = string(jsonBytes)
			params[name] = string(jsonBytes)

			r.log.Debugf(ctx, "Post: built payload '%s'", name)
		}
	}

	output["payloads"] = builtPayloads

	// Step 2: Execute post actions
	results := make([]any, 0)
	if actionsRaw, ok := args["postActions"].([]any); ok && len(actionsRaw) > 0 {
		r.log.Infof(ctx, "Post: executing %d post actions", len(actionsRaw))

		for _, actionRaw := range actionsRaw {
			action, ok := actionRaw.(map[string]any)
			if !ok {
				continue
			}

			name, _ := action["name"].(string)
			result := map[string]any{
				"name":   name,
				"status": "success",
			}

			// Execute log action if present
			if logConfig, ok := action["log"].(map[string]any); ok {
				message, _ := logConfig["message"].(string)
				level, _ := logConfig["level"].(string)
				if level == "" {
					level = "info"
				}

				// Render template in message
				renderedMessage, err := RenderTemplate(message, params)
				if err == nil {
					message = renderedMessage
				}

				switch level {
				case "debug":
					r.log.Debugf(ctx, "PostAction[%s]: %s", name, message)
				case "warning", "warn":
					r.log.Warnf(ctx, "PostAction[%s]: %s", name, message)
				case "error":
					r.log.Errorf(ctx, "PostAction[%s]: %s", name, message)
				default:
					r.log.Infof(ctx, "PostAction[%s]: %s", name, message)
				}
			}

			// Execute API call if present
			if apiCallConfig, ok := action["apiCall"].(map[string]any); ok {
				apiResult, err := r.executeAPICall(ctx, apiCallConfig, params)
				if err != nil {
					result["status"] = "failed"
					result["error"] = err.Error()
					allSuccess = false
					results = append(results, result)
					break
				}
				result["apiCallMade"] = true
				result["httpStatus"] = apiResult["statusCode"]
				result["apiResponse"] = apiResult["body"]
			}

			results = append(results, result)
			r.log.Infof(ctx, "PostAction[%s]: SUCCESS", name)
		}
	}

	output["results"] = results
	output["success"] = allSuccess

	return output, nil
}

// buildPayload builds a payload from a build definition.
func (r *PostTaskRunner) buildPayload(ctx context.Context, build any, evaluator *criteria.Evaluator, params map[string]any) (any, error) {
	switch v := build.(type) {
	case map[string]any:
		return r.buildMapPayload(ctx, v, evaluator, params)
	default:
		return build, nil
	}
}

// buildMapPayload builds a map payload, evaluating expressions as needed.
func (r *PostTaskRunner) buildMapPayload(ctx context.Context, m map[string]any, evaluator *criteria.Evaluator, params map[string]any) (map[string]any, error) {
	result := make(map[string]any)

	for k, v := range m {
		// Render the key
		renderedKey, err := RenderTemplate(k, params)
		if err != nil {
			return nil, fmt.Errorf("failed to render key '%s': %w", k, err)
		}

		// Process the value
		processedValue, err := r.processValue(ctx, v, evaluator, params)
		if err != nil {
			return nil, fmt.Errorf("failed to process value for key '%s': %w", k, err)
		}

		result[renderedKey] = processedValue
	}

	return result, nil
}

// processValue processes a value, evaluating expressions as needed.
func (r *PostTaskRunner) processValue(ctx context.Context, v any, evaluator *criteria.Evaluator, params map[string]any) (any, error) {
	switch val := v.(type) {
	case map[string]any:
		// Check if this is a value definition with field or expression
		if field, ok := val["field"].(string); ok && field != "" {
			defaultVal := val["default"]
			result, err := evaluator.ExtractValue(field, "")
			if err != nil {
				return nil, err
			}
			if result.Value == nil {
				return defaultVal, nil
			}
			return result.Value, nil
		}
		if expr, ok := val["expression"].(string); ok && expr != "" {
			defaultVal := val["default"]
			result, err := evaluator.ExtractValue("", expr)
			if err != nil {
				return nil, err
			}
			if result.Value == nil {
				return defaultVal, nil
			}
			return result.Value, nil
		}

		// Recursively process nested maps
		return r.buildMapPayload(ctx, val, evaluator, params)

	case []any:
		result := make([]any, len(val))
		for i, item := range val {
			processed, err := r.processValue(ctx, item, evaluator, params)
			if err != nil {
				return nil, err
			}
			result[i] = processed
		}
		return result, nil

	case string:
		return RenderTemplate(val, params)

	default:
		return v, nil
	}
}

// executeAPICall executes an API call for a post action.
func (r *PostTaskRunner) executeAPICall(ctx context.Context, apiCallConfig map[string]any, params map[string]any) (map[string]any, error) {
	if r.apiClient == nil {
		return nil, fmt.Errorf("API client not configured")
	}

	method, _ := apiCallConfig["method"].(string)
	url, _ := apiCallConfig["url"].(string)

	// Render URL template
	renderedURL, err := RenderTemplate(url, params)
	if err == nil {
		url = renderedURL
	}

	r.log.Infof(ctx, "Post: API call %s %s", method, url)

	// Build request options
	var opts []hyperfleet_api.RequestOption

	// Add headers
	if headers, ok := apiCallConfig["headers"].(map[string]string); ok {
		opts = append(opts, hyperfleet_api.WithHeaders(headers))
	}

	// Prepare body
	var body []byte
	if bodyStr, ok := apiCallConfig["body"].(string); ok && bodyStr != "" {
		renderedBody, err := RenderTemplate(bodyStr, params)
		if err == nil {
			body = []byte(renderedBody)
		} else {
			body = []byte(bodyStr)
		}
	}

	// Execute request
	var resp *hyperfleet_api.Response

	switch strings.ToUpper(method) {
	case "GET":
		resp, err = r.apiClient.Get(ctx, url, opts...)
	case "POST":
		resp, err = r.apiClient.Post(ctx, url, body, opts...)
	case "PUT":
		resp, err = r.apiClient.Put(ctx, url, body, opts...)
	case "PATCH":
		resp, err = r.apiClient.Patch(ctx, url, body, opts...)
	case "DELETE":
		resp, err = r.apiClient.Delete(ctx, url, opts...)
	default:
		return nil, fmt.Errorf("unsupported HTTP method: %s", method)
	}

	result := make(map[string]any)

	if err != nil {
		result["error"] = err.Error()
		if resp != nil {
			result["statusCode"] = resp.StatusCode
		}
		return result, err
	}

	result["statusCode"] = resp.StatusCode
	result["status"] = resp.Status
	result["success"] = resp.IsSuccess()

	// Try to parse body as JSON
	if len(resp.Body) > 0 {
		var jsonBody map[string]any
		if err := json.Unmarshal(resp.Body, &jsonBody); err == nil {
			result["body"] = jsonBody
		} else {
			result["body"] = resp.BodyString()
		}
	}

	if !resp.IsSuccess() {
		return result, fmt.Errorf("API call returned status %d", resp.StatusCode)
	}

	return result, nil
}

func init() {
	_ = RegisterDefault(TaskPost, NewPostTaskRunner)
}
