# HyperFleet Adapter Framework Configuration Template (MVP)
#
# This is a Configuration Template for configuring cloud provider adapters
# using the HyperFleet Adapter Framework with CEL (Common Expression Language).
#
# TEMPLATE SYNTAX:
# ================
# 1. Go Templates ({{ .var }}) - Variable interpolation throughout
# 2. field: "path" - Simple JSON path extraction (translated to CEL internally)
# 3. expression: "cel" - Full CEL expressions for complex logic
#
# CONDITION SYNTAX (when:):
# =========================
# Option 1: Expression syntax (CEL)
#   when:
#     expression: |
#       clusterPhase == "Terminating"
#
# Option 2: Structured conditions (field + operator + value)
#   when:
#     conditions:
#       - field: "clusterPhase"
#         operator: "equals"
#         value: "Terminating"
#
# Supported operators: equals, notEquals, in, notIn, contains, greaterThan, lessThan, exists
#
# CEL OPTIONAL CHAINING:
# ======================
# Use optional chaining with orValue() to safely access potentially missing fields:
#   resources.?clusterNamespace.?status.?phase.orValue("")
#   adapter.?executionStatus.orValue("")
#
# Copy this file to your adapter repository and customize for your needs.

apiVersion: hyperfleet.redhat.com/v1alpha1
kind: AdapterConfig
metadata:
  # Adapter name (used as resource name and in logs/metrics)
  name: example-adapter
  namespace: hyperfleet-system
  labels:
    hyperfleet.io/adapter-type: example
    hyperfleet.io/component: adapter

# ============================================================================
# Adapter Specification
# ============================================================================
spec:
  # Adapter Information
  adapter:
    # Adapter version
    version: "0.1.0"
  
  # ============================================================================
  # HyperFleet API Configuration
  # ============================================================================
  hyperfleetApi:
    # HTTP client timeout for API calls
    timeout: 2s
    # Number of retry attempts for failed API calls
    retryAttempts: 3
    # Retry backoff strategy: exponential, linear, constant
    retryBackoff: exponential

  # ============================================================================
  # Kubernetes Configuration
  # ============================================================================
  kubernetes:
    apiVersion: "v1"
    
  # ============================================================================
  # Global params
  # ============================================================================
  # params to extract from CloudEvent and environment variables
  params:
    # Environment variables from deployment
    - name: "hyperfleetApiBaseUrl"
      source: "env.HYPERFLEET_API_BASE_URL"
      type: "string"
      description: "Base URL for the HyperFleet API"
      required: true
    
    - name: "hyperfleetApiVersion"
      source: "env.HYPERFLEET_API_VERSION"
      type: "string"
      default: "v1"
      description: "API version to use"
    
    # Extract from CloudEvent data
    - name: "clusterId"
      source: "event.id"
      type: "string"
      description: "Unique identifier for the target cluster"
      required: true
    

  # ============================================================================
  # Global Preconditions
  # ============================================================================
  # These preconditions run sequentially and validate cluster state before resource operations.
  #
  # DATA SCOPES:
  # ============
  # Capture scope (field/expression): API response data only
  #   - Access: status.phase, items[0].name, etc.
  #
  # Conditions scope (conditions/expression): Full execution context
  #   - params.*             : Original extracted params
  #   - <precondition-name>.*: Full API response (e.g., clusterStatus.status.phase)
  #   - capturedField        : Explicitly captured values
  #   - adapter.*            : Adapter metadata
  #   - resources.*          : Created resources (empty during preconditions)
  #
  preconditions:
    # ==========================================================================
    # Step 1: Get cluster status
    # ==========================================================================
    - name: "clusterStatus"
      apiCall:
        method: "GET"
        # NOTE: API path includes /api/hyperfleet/ prefix
        url: "{{ .hyperfleetApiBaseUrl }}/api/hyperfleet/{{ .hyperfleetApiVersion }}/clusters/{{ .clusterId }}"
        timeout: 10s
        retryAttempts: 3
        retryBackoff: "exponential"
      # Capture fields from the API response. Captured values become variables for use in resources section.
      # SCOPE: API response data only
      # Supports two modes:
      #   - field: Simple dot notation or JSONPath expression for extracting values
      #   - expression: CEL expression for computed values
      # Only one of 'field' or 'expression' can be set per capture.
      capture:
        # Simple dot notation
        - name: "clusterName"
          field: "name"
        - name: "clusterPhase"
          field: "status.phase"
        - name: "generationId"
          field: "generation"
        
        # JSONPath for complex extraction (filter by field value)
        # See: https://kubernetes.io/docs/reference/kubectl/jsonpath/
        # - name: "lzNamespaceStatus"
        #   field: "{.items[?(@.adapter=='landing-zone-adapter')].data.namespace.status}"
        
        # CEL expression for computed values
        # - name: "activeItemCount"
        #   expression: "items.filter(i, i.status == 'active').size()"
      
      # Conditions to check. SCOPE: Full execution context
      # You can access:
      #   - Captured values: clusterPhase, clusterName, etc.
      #   - Full API response: clusterStatus.status.phase, clusterStatus.spec.nodeCount
      #   - Params: clusterId, hyperfleetApiBaseUrl, etc.
      conditions:
        # Using captured value
        - field: "clusterPhase"
          operator: "equals"
          value: "NotReady"
        
        # Or dig directly into API response using precondition name
        # - field: "clusterStatus.status.nodeCount"
        #   operator: "greaterThan"
        #   value: 0
      
      # Alternative: CEL expression with full access
      # expression: |
      #   clusterStatus.status.phase == "Ready" && 
      #   clusterStatus.spec.nodeCount > 0
  
  # ============================================================================
  # Resources (Create/Update Resources)
  # ============================================================================
  # All resources are created/updated sequentially in the order defined below
  resources:
    # ==========================================================================
    # Resource 1: Cluster Namespace
    # ==========================================================================
    - name: "clusterNamespace"
      manifest:
        apiVersion: v1
        kind: Namespace
        metadata:
          # Use | lower to ensure valid K8s resource name (lowercase RFC 1123)
          name: "{{ .clusterId | lower }}"
          labels:
            hyperfleet.io/cluster-id: "{{ .clusterId }}"
            hyperfleet.io/managed-by: "{{ .metadata.name }}"
            hyperfleet.io/resource-type: "namespace"
          annotations:
            hyperfleet.io/created-by: "hyperfleet-adapter"
            hyperfleet.io/generation: "{{ .generationId }}"
      discovery:
        # The "namespace" field within discovery is optional:
        # - For namespaced resources: set namespace to target the specific namespace
        # - For cluster-scoped resources (like Namespace, ClusterRole): omit or leave empty
        # Here we omit it since Namespace is cluster-scoped
        bySelectors:
          labelSelector:
            hyperfleet.io/resource-type: "namespace"
            hyperfleet.io/cluster-id: "{{ .clusterId }}"
            hyperfleet.io/managed-by: "{{ .metadata.name }}"


  # ============================================================================
  # Post-Processing
  # ============================================================================
  post:
    payloads:
      # Build status payload inline
      - name: "clusterStatusPayload"
        build:
          # Adapter name for tracking which adapter reported this status
          adapter: "{{ .metadata.name }}"
          
          # Conditions array - each condition has type, status, reason, message
          # Use CEL optional chaining ?.orValue() for safe field access
          conditions:
            # Applied: Resources successfully created
            - type: "Applied"
              status:
                expression: |
                  resources.?clusterNamespace.?status.?phase.orValue("") == "Active" ? "True" : "False"
              reason:
                expression: |
                  resources.?clusterNamespace.?status.?phase.orValue("") == "Active"
                    ? "NamespaceCreated"
                    : "NamespacePending"
              message:
                expression: |
                  resources.?clusterNamespace.?status.?phase.orValue("") == "Active"
                    ? "Namespace created successfully"
                    : "Namespace creation in progress"

            # Available: Resources are active and ready
            - type: "Available"
              status:
                expression: |
                  resources.?clusterNamespace.?status.?phase.orValue("") == "Active" ? "True" : "False"
              reason:
                expression: |
                  resources.?clusterNamespace.?status.?phase.orValue("") == "Active" ? "NamespaceReady" : "NamespaceNotReady"
              message:
                expression: |
                  resources.?clusterNamespace.?status.?phase.orValue("") == "Active" ? "Namespace is active and ready" : "Namespace is not active and ready"

            # Health: Adapter execution status (runtime) Don't need to update this. This can be reused from the adapter config.
            - type: "Health"
              status:
                expression: |
                  adapter.?executionStatus.orValue("") == "success" ? "True" : (adapter.?executionStatus.orValue("") == "failed" ? "False" : "Unknown")
              reason:
                expression: |
                  adapter.?errorReason.orValue("") != "" ? adapter.?errorReason.orValue("") : "Healthy"
              message:
                expression: |
                  adapter.?errorMessage.orValue("") != "" ? adapter.?errorMessage.orValue("") : "All adapter operations completed successfully"
          
          # Use CEL expression for numeric fields to preserve type (not Go template which outputs strings)
          observed_generation:
            expression: "generationId"
            
          # Use Go template with now and date functions for timestamps
          observed_time: "{{ now | date \"2006-01-02T15:04:05Z07:00\" }}"

          # Optional data field for adapter-specific metrics extracted from resources
          data:
            namespace:
              name:
                expression: |
                  resources.?clusterNamespace.?metadata.?name.orValue("")
              status:
                expression: |
                  resources.?clusterNamespace.?status.?phase.orValue("")

    # ============================================================================
    # Post Actions
    # ============================================================================
    # Post actions are executed after resources are created/updated
    postActions:
      # Report cluster status to HyperFleet API (always executed)
      - name: "reportClusterStatus"
        apiCall:
          method: "POST"
          # NOTE: API path includes /api/hyperfleet/ prefix and ends with /statuses
          url: "{{ .hyperfleetApiBaseUrl }}/api/hyperfleet/{{ .hyperfleetApiVersion }}/clusters/{{ .clusterId }}/statuses"
          body: "{{ .clusterStatusPayload }}"
          timeout: 30s
          retryAttempts: 3
          retryBackoff: "exponential"
          headers:
            - name: "Content-Type"
              value: "application/json"
